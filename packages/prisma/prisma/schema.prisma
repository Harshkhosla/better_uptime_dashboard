// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model User {
  id      String   @id @default(uuid()) @map("_id")
  email   String   @unique
  name    String?
  password String
  webhookUrl String?  // Optional webhook URL for notifications
  resetToken String?  // Token for password reset
  resetTokenExpiry DateTime? // Expiry time for reset token
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  websites  Website[] @relation("UserWebsites")
  regionIds String[]
  userDetails UserDetails?  @relation("UserDetails")
  userDetailsFilled Boolean?
  userDemoGraphs UserDemoGraph[] @relation("UserDemoGraphs")
  mealPlans         MealPlan[]
  chatHistory       ChatHistory[]
  weightHistory     WeightHistory[]
}


model MealPlan {
  id             String      @id @default(uuid()) @map("_id")
  userId         String
  user           User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  generatedAt    DateTime    @default(now())
  numberOfDays   Int         @default(7)
  isActive       Boolean     @default(true)
  userInput      Json        // Store the input parameters used for generation
  mealStructure  Json        // Store the meal structure configuration
  days           MealDay[]
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt
}

model MealDay {
  id         String   @id @default(uuid()) @map("_id")
  mealPlanId String
  mealPlan   MealPlan @relation(fields: [mealPlanId], references: [id], onDelete: Cascade)
  date       DateTime
  meals      Meal[]
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model Meal {
  id              String      @id @default(uuid()) @map("_id")
  mealDayId       String
  mealDay         MealDay     @relation(fields: [mealDayId], references: [id], onDelete: Cascade)
  externalId      String      // The ID from LLM response (e.g., "1", "2", etc.)
  name            String
  type            String      // breakfast, snack, lunch, dinner
  calories        Int
  protein         Float
  carbs           Float
  fats            Float
  time            String
  isCompleted     Boolean     @default(false)
  completedAt     DateTime?
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
}

model ChatHistory {
  id        String   @id @default(uuid()) @map("_id")
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role      String   // "user" or "assistant"
  content   Json     // Store the message content
  metadata  Json?    // Store additional context (userDetails, mealPlan generated, etc.)
  createdAt DateTime @default(now())
}

model WeightHistory {
  id        String   @id @default(uuid()) @map("_id")
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  date      DateTime
  weight    Float
  goal      Float?
  note      String?  // Optional note about the weigh-in
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([userId, date]) // Prevent duplicate entries for same date
}

model UserDetails {
  id    String @id @default(uuid()) @map("_id")
  owner       User     @relation("UserDetails", fields: [ownerId], references: [id])
  age     Int
  weight Int
  height  Int
  goalWeight  Int?
  bmi  Int
  preferences String 
  ownerId     String @unique
}

model UserDemoGraph{
  id String @id @default(uuid()) @map("_id")
  owner       User     @relation("UserDemoGraphs", fields: [ownerId], references: [id])
  progress String 
  ownerId String
}
model NotificationPreference {
  id          String  @id @default(uuid()) @map("_id")
  notifyCall  Boolean @default(false)
  notifySMS   Boolean @default(false)
  notifyEmail Boolean @default(false)
  notifyPush  Boolean @default(false)
  websites    Website[]
}

model Website{
  id  String @id @default(uuid()) @map("_id")
  url String
  timeAdded DateTime
  uptime DateTime?
  incident Int?@default(0)
  websiteStatus WebsiteStatus[]
  alert  String?
  acknowledge       String?
  escalationPolicy  String?
  checkInterval Int @default(5) // Check interval in minutes (default: 5 minutes)
  lastEmailSentAt DateTime? // Track last email sent time for rate limiting
  notificationPref  NotificationPreference? @relation(fields: [notificationPrefId], references: [id])
  notificationPrefId String?
  owner       User      @relation("UserWebsites", fields: [ownerId], references: [id])
  ownerId     String
  incidents   Incident[] @relation("WebsiteIncidents")
}
model WebsiteStatus{
   id  String @id @default(uuid()) @map("_id")
   responseTime  Int
   statusCheck statusCheck
   region Region @relation(fields: [regionId],references: [id])
   regionId String
   website Website @relation(fields: [websiteId],references: [id])
   websiteId String
   timestamp DateTime?
}

model Region {
  id    String           @id @default(uuid()) @map("_id")
  name  String
  websiteStatuses WebsiteStatus[]
}

enum statusCheck{
  Up
  DOWN
  UNKNONE
}

// New models for incident tracking and analysis
model Incident {
  id              String   @id @default(uuid()) @map("_id")
  websiteId       String
  website         Website  @relation("WebsiteIncidents", fields: [websiteId], references: [id])
  incidentNumber  Int      // Sequential incident number for the website
  startedAt       DateTime @default(now())
  resolvedAt      DateTime?
  duration        Int?     // Duration in seconds
  severity        IncidentSeverity @default(MINOR)
  status          IncidentStatus @default(ACTIVE)
  errorType       String?  // Type of error (timeout, DNS, SSL, 5xx, etc.)
  errorMessage    String?  // Raw error message
  affectedRegions String[] // List of affected regions
  analysis        IncidentAnalysis? @relation("IncidentAnalysis")
  timeline        IncidentTimeline[] @relation("IncidentTimeline")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([websiteId, startedAt])
  @@unique([websiteId, incidentNumber])
}

model IncidentAnalysis {
  id                String   @id @default(uuid()) @map("_id")
  incidentId        String   @unique
  incident          Incident @relation("IncidentAnalysis", fields: [incidentId], references: [id], onDelete: Cascade)
  
  // AI-generated analysis
  rootCause         String?  // AI-identified root cause
  impactSummary     String?  // Summary of impact
  affectedUsers     Int?     // Estimated affected users
  recommendations   Json?    // Array of recommended actions
  preventionTips    Json?    // Tips to prevent similar incidents
  similarIncidents  Json?    // References to similar past incidents
  pattern           String?  // Identified pattern (gradual degradation, sudden failure, etc.)
  
  // Metrics
  avgResponseTime   Int?     // Average response time during incident
  errorRate         Float?   // Error rate percentage
  
  // AI metadata
  aiModel           String?  // Which AI model was used
  confidence        Float?   // Confidence score of the analysis
  
  analyzedAt        DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

model IncidentTimeline {
  id              String   @id @default(uuid()) @map("_id")
  incidentId      String
  incident        Incident @relation("IncidentTimeline", fields: [incidentId], references: [id], onDelete: Cascade)
  
  timestamp       DateTime @default(now())
  eventType       TimelineEventType
  description     String
  metadata        Json?    // Additional data about the event
  
  @@index([incidentId, timestamp])
}

enum IncidentSeverity {
  CRITICAL  // Complete outage
  MAJOR     // Significant degradation
  MINOR     // Small issues
  WARNING   // Potential issues detected
}

enum IncidentStatus {
  ACTIVE      // Currently happening
  RESOLVED    // Fixed
  MONITORING  // Fixed but monitoring
  CLOSED      // Fully closed
}

enum TimelineEventType {
  STARTED           // Incident began
  DEGRADED          // Performance degraded
  DOWN              // Complete outage
  RECOVERING        // Starting to recover
  RESOLVED          // Back to normal
  ANALYSIS_ADDED    // AI analysis completed
  USER_NOTE         // Manual note added
  NOTIFICATION_SENT // Alert sent
}
